/* Generated By:JavaCC: Do not edit this line. CTBParser200.java */
public class CTBParser200 extends CTBParser implements CTBParser200Constants {

        private final static int DIAGRAM_PARENT_IS_EVENT        = 0;
        private final static int DIAGRAM_PARENT_IS_MODULE       = 1;

        private int mDiagramParentType;

        private void setDiagramParentType(int type) {
                mDiagramParentType = type;
        }

        private int getDiagramParentType() {
                return mDiagramParentType;
        }

        private String getRouteModuleName(String param) {
                if (param == null)
                        return null;
                int idx = param.indexOf('.');
                if (idx < 0)
                        return null;

                return new String(param.getBytes(), 0, idx);
        }

        public int getRouteModuleNode(String param) {
                if (param == null)
                        return 0;
                int idx = param.indexOf('.');
                if (idx < 0)
                        return 0;

                String numberStr = new String(param.getBytes(), idx+1, param.length()-(idx+1));
                if (numberStr.equalsIgnoreCase("E") == true)
                        return -1;
                return Integer.parseInt(numberStr);
        }

///////////////////////////////////////////////
//	StringToken
///////////////////////////////////////////////
  final public String StringToken() throws ParseException {
        Token   t;
    t = jj_consume_token(STRING);
                        {if (true) return t.image.substring(1, t.image.length()-1);}
    throw new Error("Missing return statement in function");
  }

///////////////////////////////////////////////
//	StringIntegerToken
///////////////////////////////////////////////
  final public int StringIntegerToken() throws ParseException {
        String  strValue;
        int             value;
    strValue = StringToken();
                        value = 0;
                        try {
                                value = Integer.parseInt(strValue);
                        }
                        catch (NumberFormatException nfe) {}
                        {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

///////////////////////////////////////////////
//	IntegerToken
///////////////////////////////////////////////
  final public int IntegerToken() throws ParseException {
        Token t;
        int     value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      t = jj_consume_token(NUMBER);
                        {if (true) return Integer.parseInt(t.image);}
      break;
    case STRING:
      value = StringIntegerToken();
                        {if (true) return value;}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

///////////////////////////////////////////////
//	Tag Param
///////////////////////////////////////////////
  final public String VersionParam() throws ParseException {
        String name = null;
    jj_consume_token(6);
    name = StringToken();
                        {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public String NameParam() throws ParseException {
        String name = null;
    jj_consume_token(7);
    name = StringToken();
                        {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public String ClassParam() throws ParseException {
        String cname = null;
    jj_consume_token(8);
    cname = StringToken();
                        {if (true) return cname;}
    throw new Error("Missing return statement in function");
  }

  final public String TypeParam() throws ParseException {
        String type = null;
    jj_consume_token(9);
    type = StringToken();
                        {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public String OptionParam() throws ParseException {
        String opt = null;
    jj_consume_token(10);
    opt = StringToken();
                        {if (true) return opt;}
    throw new Error("Missing return statement in function");
  }

  final public String ValueParam() throws ParseException {
        String value = null;
    jj_consume_token(11);
    value = StringToken();
                        {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public int XPosParam() throws ParseException {
        int             value;
        String  valueString;
    jj_consume_token(12);
    value = IntegerToken();
                        {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public int YPosParam() throws ParseException {
        int     value;
    jj_consume_token(13);
    value = IntegerToken();
                        {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public int WidthParam() throws ParseException {
        int     value;
    jj_consume_token(14);
    value = IntegerToken();
                        {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public int HeightParam() throws ParseException {
        int     value;
    jj_consume_token(15);
    value = IntegerToken();
                        {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public String OutModuleParam() throws ParseException {
        String name = null;
    jj_consume_token(16);
    name = StringToken();
                        {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public String InModuleParam() throws ParseException {
        String name = null;
    jj_consume_token(17);
    name = StringToken();
                        {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

///////////////////////////////////////////////
//	CBF (CyberToolbox Behavior File format)
///////////////////////////////////////////////
  final public void CBFTag() throws ParseException {
        String  verString;
    jj_consume_token(18);
    verString = VersionParam();
    jj_consume_token(19);
                        setFormatType(FORMATTYPE_CBF);
                        setVersionString(verString);
  }

  final public void CBF() throws ParseException {
    CBFTag();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 23:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      Event();
    }
    jj_consume_token(20);

  }

///////////////////////////////////////////////
//	CDF (CyberToolbox Diagram File format)
///////////////////////////////////////////////
  final public void CDFTag() throws ParseException {
        String  verString;
    jj_consume_token(21);
    verString = VersionParam();
    jj_consume_token(19);
                        setFormatType(FORMATTYPE_CDF);
                        setVersionString(verString);
  }

  final public void CDF() throws ParseException {
        String  verString;
    CDFTag();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 25:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      Diagram();
    }
    jj_consume_token(22);

  }

///////////////////////////////////////////////
//	Event
///////////////////////////////////////////////
  final public void EventParam() throws ParseException {
        String  value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 7:
      value = NameParam();
                        getCurrentEvent().setName(value);
      break;
    case 10:
      value = OptionParam();
                        getCurrentEvent().setOptionString(value);
      break;
    case 9:
      value = TypeParam();
                        getCurrentEvent().setAttribute(value);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void EventTag() throws ParseException {
    jj_consume_token(23);
                        Event event = new Event();
                        event.setWorld(getWorld());
                        addEvent(event);
                        setDiagramParentType(DIAGRAM_PARENT_IS_EVENT);
                        pushObject(event);
  }

  final public void Event() throws ParseException {
    EventTag();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 7:
      case 9:
      case 10:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
      EventParam();
    }
    jj_consume_token(19);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 25:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_4;
      }
      Diagram();
    }
    jj_consume_token(24);
                        Event   event = getCurrentEvent();

                        String  name                                    = event.getName();
                        String  optionString            = event.getOptionString();
                        int             attribute                       = event.getAttribute();

                        EventType eventType = null;

                        switch (attribute) {
                        case EventType.ATTRIBUTE_SYSTEM:
                                {
                                        eventType = getWorld().getSystemEventType(name);
                                }
                                break;
                        case EventType.ATTRIBUTE_USER:
                                {
                                        eventType = getWorld().getUserEventType(name);
                                        event.setOptionString(optionString);
                                }
                                break;
                        default: // case EventType.ATTRIBUTE_NONE:
                                {
                                        if (optionString != null) {
                                                eventType = getWorld().getUserEventType(name);
                                                event.setOptionString(optionString);
                                        }
                                        else
                                                eventType = getWorld().getSystemEventType(name);
                                }
                                break;
                        }

                        event.setEventType(eventType);

                        popObject();
  }

///////////////////////////////////////////////
//	Diagram
///////////////////////////////////////////////
  final public void DiagramParam() throws ParseException {
        String  strValue;
        int             intValue;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 7:
      strValue = NameParam();
                        getCurrentDiagram().setName(strValue);
      break;
    case 12:
      intValue = XPosParam();
                        getCurrentDiagram().setXPosition(intValue);
      break;
    case 13:
      intValue = YPosParam();
                        getCurrentDiagram().setYPosition(intValue);
      break;
    case 14:
      intValue = WidthParam();
                        getCurrentDiagram().setWidth(intValue);
      break;
    case 15:
      intValue = HeightParam();
                        getCurrentDiagram().setHeight(intValue);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void DiagramTag() throws ParseException {
    jj_consume_token(25);
                        Diagram dgm = new Diagram();

                        switch (getDiagramParentType()) {
                        case DIAGRAM_PARENT_IS_EVENT:
                                {
                                        if (getFormatType() == FORMATTYPE_CBF) {
                                                Event event = getCurrentEvent();
                                                event.addDiagram(dgm);
                                        }
                                        if (getFormatType() == FORMATTYPE_CDF) {
                                                addDiagram(dgm);
                                        }
                                }
                                break;
                        case DIAGRAM_PARENT_IS_MODULE:
                                {
                                        ModuleInfo modInfo = getCurrentModuleInfo();
                                        modInfo.setInsideDiagram(dgm);
                                }
                                break;
                        }

                        pushObject(dgm);
  }

  final public void Diagram() throws ParseException {
    DiagramTag();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 7:
      case 12:
      case 13:
      case 14:
      case 15:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_5;
      }
      DiagramParam();
    }
    jj_consume_token(19);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 27:
      case 31:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 27:
        Module();
        break;
      case 31:
        Route();
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(26);
                        popObject();
  }

///////////////////////////////////////////////
//	Module
///////////////////////////////////////////////
  final public void ModuleParam() throws ParseException {
        String  strValue;
        int             intValue;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 8:
      strValue = ClassParam();
                        getCurrentModuleInfo().setClassName(strValue);
      break;
    case 9:
      strValue = TypeParam();
                        getCurrentModuleInfo().setTypeName(strValue);
      break;
    case 7:
      strValue = NameParam();
                        getCurrentModuleInfo().setName(strValue);
      break;
    case 11:
      strValue = ValueParam();
                        getCurrentModuleInfo().setValue(strValue);
      break;
    case 12:
      intValue = XPosParam();
                        getCurrentModuleInfo().setXPosition(intValue);
      break;
    case 13:
      intValue = YPosParam();
                        getCurrentModuleInfo().setYPosition(intValue);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ModuleTag() throws ParseException {
    jj_consume_token(27);
                        ModuleInfo modInfo = new ModuleInfo();
                        setDiagramParentType(DIAGRAM_PARENT_IS_MODULE);
                        pushObject(modInfo);
  }

  final public void Module() throws ParseException {
    ModuleTag();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 7:
      case 8:
      case 9:
      case 11:
      case 12:
      case 13:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_7;
      }
      ModuleParam();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 28:
      jj_consume_token(28);
      break;
    case 19:
      jj_consume_token(19);
      Diagram();
      jj_consume_token(29);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                        ModuleInfo modInfo = getCurrentModuleInfo();
                        ModuleType modType = getWorld().getModuleType(modInfo.getClassName(), modInfo.getTypeName());

                        popObject();

                        Diagram dgm = getCurrentDiagram();
                        if (modType != null) {
                                Module module = dgm.addModule(modType);
                                if (module != null) {
                                        module.setName(modInfo.getName());
                                        module.setValue(modInfo.getValue());
                                        module.setPosition(modInfo.getXPosition(), modInfo.getYPosition());
                                        if (module.isInsideDiagram() == true) {
                                                Diagram insideDgm = modInfo.getInsideDiagram();
                                                insideDgm.setParentModule(module);
                                                module.setInsideDiagram(insideDgm);
                                        }
                                }
                        }
                        else
                                Debug.warning("Coundn't find the module type (" + modInfo.getClassName() + ", " + modInfo.getTypeName() + ")");
                        setDiagramParentType(DIAGRAM_PARENT_IS_EVENT);
  }

///////////////////////////////////////////////
//	ROUTE
///////////////////////////////////////////////
  final public String ModuleNameToken() throws ParseException {
        Token   t;
    t = jj_consume_token(ID);
                        {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public int NodeNumberToken() throws ParseException {
        int     number;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
    case STRING:
      number = IntegerToken();
                        {if (true) return number;}
      break;
    case 30:
      jj_consume_token(30);
                        {if (true) return -1;}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void Route() throws ParseException {
        String  inModuleParam;
        String  outModuleParam;
        String  inModuleName;
        int             inModuleNode;
        String  outModuleName;
        int             outModuleNode;
    jj_consume_token(31);
    outModuleParam = OutModuleParam();
    inModuleParam = InModuleParam();
    jj_consume_token(28);
                        inModuleName    = getRouteModuleName(inModuleParam);
                        inModuleNode    = getRouteModuleNode(inModuleParam);
                        outModuleName   = getRouteModuleName(outModuleParam);
                        outModuleNode   = getRouteModuleNode(outModuleParam);
                        getCurrentDiagram().addDataflow(outModuleName, outModuleNode, inModuleName, inModuleNode);
  }

  final public void Input() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 18:
      CBF();
      break;
    case 21:
      CDF();
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(0);
  }

  public CTBParser200TokenManager token_source;
  ASCII_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[15];
  final private int[] jj_la1_0 = {0x0,0x800000,0x2000000,0x680,0x680,0x2000000,0xf080,0xf080,0x88000000,0x88000000,0x3b80,0x3b80,0x10080000,0x40000000,0x240000,};
  final private int[] jj_la1_1 = {0x5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,};

  public CTBParser200(java.io.InputStream stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new CTBParser200TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public CTBParser200(java.io.Reader stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new CTBParser200TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public CTBParser200(CTBParser200TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public void ReInit(CTBParser200TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[35];
    for (int i = 0; i < 35; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 15; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 35; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
